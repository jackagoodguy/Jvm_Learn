package com.java.meet.c72_80_reference;

/**
 * 72_强引用Reference
 * ...
 * 80_GCRoots和四大引用小总结
 *
 *
 * 强引用、软引用、弱引用、虚引用分别是什么？
 *      整体架构
 *
 *
 *      强引用（默认支持模式）95%都是这种
 *              当内存不足，JVM开始垃圾回收，对于强引用的对象，就算是出现了OOM也不会对该对象进行回收，死都不收。
 *
 *              强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还"活着"，垃圾收集器不会碰这种对象。在Java
 *              中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达
 *              状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要
 *              原因之一。
 *
 *              对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者是显式地将相应（强）引用赋值为null,
 *              一般认为就是可以被垃圾收集的（当然具体回收时机还是要看垃圾收集策略）。
 *
 *      软引用
 *              软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。
 *
 *              对于只有软引用的对象来说，
 *                      当系统内存充足时它       不会      被回收
 *                      当系统内存不足时它         会      被回收
 *              软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收！
 *
 *
 *      弱引用
 *              弱引用需要用java.lang.ref.WeekReference类来实现，它比软引用的生存期更短
 *
 *              对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存
 *
 *              软引用和弱引用的适用场景
 *                      假如有一个应用需要读取大量的本地图片：
 *                      1.如果每次读取图片都从硬盘读取则会严重影响性能
 *                      2.如果一次性全部加载到内存中又可能造成内存溢出
 *                      此时使用软引用可以解决这个问题。
 *                        设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，
 *                        在内存不足时，JVM会自动回收这些缓存图片对象占用的空间，从而有效地避免了OOM的问题。
 *                        Map<String, SoftReference<BitMap>> imageCache = new HashMap<String, SoftReference<BitMap>>();
 *
 *               你知道弱引用的话，能谈谈WeakHashMap吗？
 *
 *      虚引用
 *              引用队列: 我被回收前需要被引用队列保存下。
 *              虚引用需要java.lang.ref.PhantomRefence类来实现
 *
 *              顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。
 *              如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都被垃圾回收器回收，它不能单独使用也不能通过它访问
 *              对象，虚引用必须和引用队列（ReferenceQueue）联合使用。
 *
 *              虚引用的主要作用是跟踪以象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。
 *              PhantomReference的get方法总是返回null,因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，
 *              可以被gc回收，用来实现比finalization机制更灵活的回收操作。
 *
 *              换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步的处理。
 *              Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。
 *
 *      GCRoots和四大引用小总结
 *              强引用：与根对象无联系；与根对象无联系，与上个对象相互引用
 *              软引用：内存紧张时回收
 *              弱引用：弱引用必定被回收
 *              虚引用：虚引用必定被回收
 *
 */


public class C_72_80_StrongReferenceDemo {

    public static void main(String[] args) {
        Object obj1 = new Object(); // 这样定义的默认就是强引用
        Object obj2 = obj1; // obj2引用赋值
        obj1 = null; // 置空
        System.gc();
        // obj2就是强引用，即使obj1指向null，obj2也不回收
        System.out.println(obj2);

    }
}
