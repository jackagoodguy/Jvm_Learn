package com.java.meet.c56_71_params;


/**
 * 56_JVMGC下半场技术加强和前提知识要求
 * 57_JVMGC快速回顾复习串讲
 * 58_谈谈你对GCRoots的理解
 *
 * JVM内存结构
 *      JVM体系概述
 *          类加载器、运行时数据区【Java栈、本地方法栈、程序计数器】线程私有不存在垃圾加收；方法区、堆，线程公有存在垃圾回收
 *
 *      Java8以后的JVM
 *
 *
 * GC的作用域
 *
 *
 *
 * 常见的垃圾回收算法
 *      引用计数（JVM的实现一般不采用这种方式）
 *          缺点：1.每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗；
 *               2.较难处理循环引用
 *
 *      复制（MinorGC的过程（复制-> 清空 -> 互换））
 *          优点：没有产生内存碎片
 *          缺点：放费空间，有一些大对象复制起来比较耗时
 *
 *          Java堆从GC的角度还可以细分为：新生代(Eden区、From Survivor区和To Survivor区) 和老年代
 *          【               Young          】   【      Old老年代      】
 *          【Eden 8/10】【From1/10】【To1/10】   【  老年代（2/3)堆空间  】
 *
 *          1：eden、SurvivorFrom复制到SurvivorTo,年龄+1
 *              首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区，当Eden
 *              区再次触发GC的时候会扫描Eden区和From区域，对这两个区域进行垃圾回收，经过这次回
 *              收后还存活的对角，则直接复制到To区域（如果有对角的年龄已经达到了老年的标准，则赋
 *              值到老年代区），同时把这些对象的年龄+1
 *
 *          2：清空 eden、SurvivorFrom
 *              然后，清空Eden和SurvivorFrom中的对象，也即复制之后有交换，谁空谁是to
 *
 *          3: SurvivorTo和SurvivorFrom互换
 *              最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分
 *              对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，
 *              这个参数默认是15），最终如果还是存活，就存入老年代
 *
 *      标记清除（Mark-Sweep），用于老年代多些
 *          缺点：产生了内存碎片
 *          算法分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象
 *
 *
 *      标记整理（在标记清除的基础上进行优化），用于老年代多些
 *          原理：
 *              1.标记，与标记-清除一样
 *              2.压缩，再次扫描，并往一端滑动存活对象，这样会产生连续空闲内存区域
 *          优点：没有内存碎片，可以利用bump
 *          缺点：需要移动对象的成本
 *
 *
 *
 */

/**
 * JVM回收的时候确定垃圾？是否知道什么是GC Roots
 *
 * 什么是垃圾？
 *      简单的说就是内存中已经不再被使用到的空间就是垃圾
 * 要进行垃圾回收，如何判断一个对象是否可以被回收？
 *      1.引用计数法（该算法存在，但目前无人用了，解决不掉循环引用的问题，了解即可）
 *          Java中，引用和对象是有关联的。如果要操作对象则必须用引用进行。
 *          因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器，
 *          每当有一个地方引用它，计数器值加1，
 *          每当有一个引用失效时，计数器值减1。
 *          任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象。
 *          那为什么主流的Java虚拟机里面都没有选用这种算法呢？其中最主要的原因是它很难解决对象之间相互循环引用的问题
 *
 *          缺点：
 *              1.每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗；
 *              2.较难处理循环引用；
 *          JVM的实现一般不采用这种方式
 *
 *      2.枚举根节点做可达性分析（根搜索路径）
 *          为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。
 *          所谓"GC roots"或者说tracing GCr "根集合"就是一组必须活跃的引用。
 *
 *          基本思路就是通过一系列名为"GC Roots"的对象作为起点，从这个被称为GC Roots的对象开始向下
 *          搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的
 *          引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活；没有
 *          被遍历到的就自然被判定为死亡。
 *
 *          Java中可以作为GC Roots的对象：
 *              1.虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。
 *              2.方法区中的类静态属性引用的对象。
 *              3.方法区中常量引用的对象。
 *              4.本地方法栈中JNI(Native方法）引用的对象。
 *
 *
 *
 *
 *
 */
public class C_56_58_GCRootDemo {

    private byte[] byteArray = new byte[100 * 1024 * 1024];
    //private static GCRootDemo t2;
    //private static final GCRootDemo t3 = new GCRootDemo();

    public static void m1() {
        C_56_58_GCRootDemo t1 = new C_56_58_GCRootDemo();
        System.gc();
        System.out.println("第一次GC完成");
    }

    public static void main(String[] args) {
        m1();
    }
}




