package com.java.basic.c10_fanshe.c01_classloader;

/**
 * @Author: Lei
 * @E-mail: 843291011@qq.com
 * @Date: Created in 10:30 上午 2020/3/28
 * @Version: 1.0
 * @Modified By:
 * @Description:
 */

import java.sql.SQLOutput;

/**
 * day27_01类加载的过程
 *
 * 类的加载
 *   1、加载
 *   2、连接
 *      （1）校验：其中一项看字节码的数据是否以"魔数cafe"
 *              以及当前的JVM的运行的JDK版本是否可以运行该字节码的数据。例如：JDK1.8可以运行用JDK1.7编译的字节码，反过来不行
 *      （2）准备
 *              给成员变量（类变量/静态变量）赋默认值
 *              把常量（final)等值在方法区的常量池中给准备好。
 *      （3）解析
 *              虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程
 *              理解为把类中的对应的类型名换成 该类型的Class对象的地址
 *              String --> String类型对应的Class地址
 *
 *   3、初始化 <clinit>类初始化由两部分组成：
 *      （1）静态变量的显式初始化代码，赋值代码
 *      （2）静态代码块
 *              （1）和（2）的顺序从上往下
 *
 *          当一个类初始化时，发现它的父类如果没有初始化，会先初始化父类。
 *          每一个类只会初始化一次，并且类初始化的过程是线程安全。
 *
 *          哪些操作会导致类的初始化？这句话的意思，类的加载不一定就会发生类初始化。虽然大多数时候，在类的加载时直接就初始化了
 *          （1）main方法所在的类在加地昔，直接就先初始化
 *          （2）new一个类的对象，一定会先完成类的初始化
 *          （3）调用该类的静态变量（final的常量除外）和静态方法
 *          （4）使用java.lang.reflect包的方法对类进行反射调用
 *          （5）当初始化一个类，如果其父类没有初始化，则先会初始化他的父类
 *
 *          哪些情况不会导致类的初始化？
 *              （1）引用静态常量（final) 不会触发此类的初始化
 *              （2）当访问一个静态域时，只有真正声明这个域的类才会被初始化
 *                      换句话说，通过子类访问父类的静态域时，只会初始化父类，不会初始化子类。
 *              （3）
 *
 *
 */
public class C01_TestClassLoader {
    private static int num = 10;

    static {
        System.out.println("main所在的类的初始化");
    }

    public static void main(String[] args) {

    }
}
