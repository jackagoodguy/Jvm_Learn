如何测算算法的优劣

        时间测算
                计算算法时间差
                幅度不够循环来凑
                一般是时间复杂度我们都是讲的"最差"的情况
        空间测算

Big O
    时间-问题（数据）规模
    【重点】计算执行最多的语句，随着规模的扩大的规律
        不考虑必须要做的操作
            循环、赋初值、程序初始化...
        不考虑常数项
            2n --- n
        不考虑低次项
            n^2 + n --- n^2


如何写算法程序
    由简单到复杂
        验证一步走一步
        多打印中间结果
    先局部后整体
        没思路时先细分
    先粗糙后精细
        变量更名
        语句合并
        边界处理


验证算法-对数器
    如何验算你的算法是否正确？
        1、肉眼观察
        2、产生足够多随机样本
        3、用确定正确的算法计算样本结果
        4、对比被验证算法的结果
.

算法的稳定性定义为,对于待排序列中相同项的原来次序不能被算法改变则称该算法稳定.
        比如待排序列为:(2) 3 6 [2] 4 5 ,,,序列中的(2)排在[2]前面,不能因为算法把[2]排到(2)前面.
        直接选择排序算法,不稳定性,举个简单的例子,就知道它是否稳定..例如:(7) 2 5 9 3 4 [7] 1...
        当我们利用直接选择排序算法进行排序时候,(7)和1调换,(7)就跑到了[7]的后面了,原来的次序改变了,这样就不稳定了.


====================
简单排序算法总结
常见的算法时间复杂度由小到大依次为：
Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)

    选择：时间复杂度n^2，空间复杂度1，不稳定
        基本不用，不稳，最简单但是最没用的排序算法，也有优化空间

    冒泡：时间复杂度n^2，空间复杂度1，稳定
        基本不用，太慢
        冒泡排序解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度O(n^2)。
        假如我们的计算机每秒钟可以运行10亿次，那么对1亿个数进行排序，桶排序只需要0.1秒，而冒泡排序则需要1千万秒，达到115天之久。
        那么，有没有一种既不浪费空间又可以快一点的排序算法呢？

    插入【重点】：时间复杂度n^2，空间复杂度1，稳定
        对于基本有序的数组最好用
        样本小且基本有序的时候效率比较高

    堆排序【重点】：时间复杂度 N*log2N，空间复杂度1，不稳定

    希尔排序：时间复杂度n^1.3，空间复杂度1，不稳


    归并【重点】：时间复杂度 N*log2N，空间复杂度N，稳定
        归并排序merge sort
        TIM SORT
        JAVA对象排序专用

    快速排序【重点】：时间复杂度N*log2N，空间复杂度log2N，不稳定

    桶排序：时间复杂度n+k，空间复杂度n+k，稳定
        普通的桶排序并不太常用，因为数据分到桶里，还得对桶进行排序，每个桶还得分配空间进行存储
        数组排序较为方便，链表排序时间复杂度很高n^2
        实际上空间做到最好的话，就只能用链表，时间就做不到最好；
        不太重要，理解就好；重点了解基数排序和计数排序

    计数排序：时间复杂度n+k，空间复杂度n+k，稳定

    基数排序：时间复杂度n*k，空间复杂度n+k，稳定



