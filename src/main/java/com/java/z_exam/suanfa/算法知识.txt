如何测算算法的优劣

        时间测算
                计算算法时间差
                幅度不够循环来凑
                一般是时间复杂度我们都是讲的"最差"的情况
        空间测算

Big O
    时间-问题（数据）规模
    【重点】计算执行最多的语句，随着规模的扩大的规律
        不考虑必须要做的操作
            循环、赋初值、程序初始化...
        不考虑常数项
            2n - n
        不考虑低次项
            n^2 + n --- n^2


如何写算法程序
    由简单到复杂
        验证一步走一步
        多打印中间结果
    先局部后整体
        没思路时先细分
    先粗糙后精细
        变量更名
        语句合并
        边界处理

选择排序：时间复杂度O(n^2)，还没用
   最简单但是最没用的排序算法，也有优化空间


验证算法-对数器
    如何验算你的算法是否正确？
        1、肉眼观察
        2、产生足够多随机样本
        3、用确定正确的算法计算样本结果
        4、对比被验证算法的结果


====================
简单排序算法总结
    冒泡：
        基本不用，太慢
        冒泡排序解决了桶排序浪费空间的问题，但在算法的执行效率上却牺牲了很多，它的时间复杂度O(n^2)。
        假如我们的计算机每秒钟可以运行10亿次，那么对1亿个数进行排序，桶排序只需要0.1秒，而冒泡排序则需要1千万秒，达到115天之久。
        那么，有没有一种既不浪费空间又可以快一点的排序算法呢？
    选择：
        基本不用，不稳
    插入：
        样本小且基本有序的时候效率比较高
    归并：
        归并排序merge sort
        TIM SORT
        JAVA对象排序专用

    快速排序：



